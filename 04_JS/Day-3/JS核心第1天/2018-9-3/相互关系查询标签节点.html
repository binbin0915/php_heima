<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<ul id="u">
    <li>你好1</li>
    <li>你好2</li>
    <li>你好3</li>
    <li>你好4</li>
</ul>
<script>
    /*********** 根据父节点查找子节点 *************/
    //先找到父节点
    // var ul = document.getElementByTagName('ul')[0];
    // var ul = document.getElementById('u');
    // var ul = document.querySelector('#u');

    //*********** 查询所有ul的子节点 --children
    //var lis = ul.children;  //查询ul的所有子节点
    //console.log(lis);

    //*********** 查询所有ul的子节点  --childNodes  这种方法把li之间的空白页算成一个子元素
    //var lis = ul.childNodes;    //这种方法只有把空白的地方删除掉才可以得到真正的li
    //console.log(lis);   //nodeType 表示节点的类型 =3 的时候表示文本，可以过滤掉空白。但是比较麻烦

    //*********** 查询所有ul的子节点 --
    //var lis = ul.getElementByTagName('li');   //在ul中查找所有的ul后代中的li
    //console.log(lis);

    //*********** 根据子节点查找父节点
    //随便找一个子节点
    // var nihao2 = document.getElementsByTagName('li')[1];
    // var ul2 = nihao2.parentNode;
    // console.log(ul2);

    //*********** 兄弟关系查询
    //随便找一个子节点
    var n2 = document.getElementsByTagName('li')[1];
    //查询上一个兄弟
    //var n1 = n2.previousSibling;
    //console.log(n1);    //还是会把空格认为是自己的上一个兄弟

    var n1 = n2.previousElementSibling;
    console.log(n1);    //常用的，但是IE8+才支持

    //查询下一个兄弟   --  nextSibling
    //查找下一个兄弟   --  nextElementSibling
</script>
</body>
</html>